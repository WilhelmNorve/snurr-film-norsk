/* tslint:disable */
/* eslint-disable */
/**
 * Tikitok Norge API
 * Dette er en komplett OpenAPI 3.1-spesifikasjon for en TikTok-lignende app.  **Omfang** - **Klient/Frontend-API**: Endepunkter som brukes av mobil- og webklienter (autentisering, feed, videoer, kommentarer, likes, følgerelasjoner, søk, varsler, opplasting m.m.). - **Backend/Admin-API**: Moderasjon, innholdsflagg, overstyringer, metrikker og backoffice-jobber. - **Webhooks**: Hendelser sendt til tredjepart-/interne konsumenter.  **Konvensjoner** - Versjonering via URL (`/v1`) og `X-API-Version` header. - Cursor-basert paginering med `next_cursor` og `prev_cursor`. - Alle tidsstempler i ISO 8601 (UTC). - Feil følger RFC 9457-lignende struktur. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Ad
 */
export interface Ad {
    /**
     * 
     * @type {string}
     * @memberof Ad
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ad
     */
    'creative_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ad
     */
    'click_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ad
     */
    'advertiser'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ad
     */
    'disclosure_label'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokens
 */
export interface AuthTokens {
    /**
     * 
     * @type {string}
     * @memberof AuthTokens
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokens
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof AuthTokens
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof AuthTokens
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'id'?: string;
    /**
     * 
     * @type {PublicUser}
     * @memberof Comment
     */
    'author'?: PublicUser;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'likes_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'parent_id'?: string;
}
/**
 * 
 * @export
 * @interface CommentCreate
 */
export interface CommentCreate {
    /**
     * 
     * @type {string}
     * @memberof CommentCreate
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CommentCreate
     */
    'parent_id'?: string;
}
/**
 * 
 * @export
 * @interface CommentEvent
 */
export interface CommentEvent {
    /**
     * 
     * @type {string}
     * @memberof CommentEvent
     */
    'event'?: CommentEventEventEnum;
    /**
     * 
     * @type {Comment}
     * @memberof CommentEvent
     */
    'comment'?: Comment;
    /**
     * 
     * @type {string}
     * @memberof CommentEvent
     */
    'video_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEvent
     */
    'fired_at'?: string;
}

export const CommentEventEventEnum = {
    CommentCreated: 'comment.created'
} as const;

export type CommentEventEventEnum = typeof CommentEventEventEnum[keyof typeof CommentEventEventEnum];

/**
 * 
 * @export
 * @interface FeatureFlag
 */
export interface FeatureFlag {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlag
     */
    'key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'rollout_percent'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlag
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FeatureFlagUpdate
 */
export interface FeatureFlagUpdate {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagUpdate
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagUpdate
     */
    'rollout_percent'?: number;
}
/**
 * 
 * @export
 * @interface FeedItem
 */
export interface FeedItem {
    /**
     * 
     * @type {Video}
     * @memberof FeedItem
     */
    'video'?: Video;
    /**
     * Forklarbarhet for anbefaling
     * @type {Array<string>}
     * @memberof FeedItem
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {Ad}
     * @memberof FeedItem
     */
    'ad'?: Ad;
}
/**
 * 
 * @export
 * @interface FeedResponse
 */
export interface FeedResponse {
    /**
     * 
     * @type {Array<FeedItem>}
     * @memberof FeedResponse
     */
    'data'?: Array<FeedItem>;
    /**
     * 
     * @type {string}
     * @memberof FeedResponse
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedResponse
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface Hashtag
 */
export interface Hashtag {
    /**
     * 
     * @type {string}
     * @memberof Hashtag
     */
    'tag'?: string;
    /**
     * 
     * @type {number}
     * @memberof Hashtag
     */
    'usage_count'?: number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'grant_type': LoginRequestGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'oidc_provider'?: LoginRequestOidcProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'oidc_token'?: string;
}

export const LoginRequestGrantTypeEnum = {
    Password: 'password',
    Oidc: 'oidc'
} as const;

export type LoginRequestGrantTypeEnum = typeof LoginRequestGrantTypeEnum[keyof typeof LoginRequestGrantTypeEnum];
export const LoginRequestOidcProviderEnum = {
    Vipps: 'vipps',
    Google: 'google',
    Apple: 'apple'
} as const;

export type LoginRequestOidcProviderEnum = typeof LoginRequestOidcProviderEnum[keyof typeof LoginRequestOidcProviderEnum];

/**
 * 
 * @export
 * @interface ModerationAction
 */
export interface ModerationAction {
    /**
     * 
     * @type {string}
     * @memberof ModerationAction
     */
    'action': ModerationActionActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ModerationAction
     */
    'notes'?: string;
}

export const ModerationActionActionEnum = {
    Keep: 'keep',
    Remove: 'remove',
    Shadowban: 'shadowban',
    BanUser: 'ban_user',
    AgeGate: 'age_gate'
} as const;

export type ModerationActionActionEnum = typeof ModerationActionActionEnum[keyof typeof ModerationActionActionEnum];

/**
 * 
 * @export
 * @interface ModerationEvent
 */
export interface ModerationEvent {
    /**
     * 
     * @type {string}
     * @memberof ModerationEvent
     */
    'event'?: ModerationEventEventEnum;
    /**
     * 
     * @type {ModerationItem}
     * @memberof ModerationEvent
     */
    'item'?: ModerationItem;
    /**
     * 
     * @type {string}
     * @memberof ModerationEvent
     */
    'fired_at'?: string;
}

export const ModerationEventEventEnum = {
    ModerationFlagged: 'moderation.flagged'
} as const;

export type ModerationEventEventEnum = typeof ModerationEventEventEnum[keyof typeof ModerationEventEventEnum];

/**
 * 
 * @export
 * @interface ModerationItem
 */
export interface ModerationItem {
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'target_type'?: ModerationItemTargetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'target_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModerationItem
     */
    'flags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'severity'?: ModerationItemSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModerationItem
     */
    'created_at'?: string;
}

export const ModerationItemTargetTypeEnum = {
    Video: 'video',
    Comment: 'comment',
    User: 'user'
} as const;

export type ModerationItemTargetTypeEnum = typeof ModerationItemTargetTypeEnum[keyof typeof ModerationItemTargetTypeEnum];
export const ModerationItemSeverityEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high',
    Critical: 'critical'
} as const;

export type ModerationItemSeverityEnum = typeof ModerationItemSeverityEnum[keyof typeof ModerationItemSeverityEnum];

/**
 * 
 * @export
 * @interface ModerationResult
 */
export interface ModerationResult {
    /**
     * 
     * @type {string}
     * @memberof ModerationResult
     */
    'status'?: ModerationResultStatusEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModerationResult
     */
    'updated_resource'?: { [key: string]: any; };
}

export const ModerationResultStatusEnum = {
    Applied: 'applied',
    Rejected: 'rejected'
} as const;

export type ModerationResultStatusEnum = typeof ModerationResultStatusEnum[keyof typeof ModerationResultStatusEnum];

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'type'?: NotificationTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Notification
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'read'?: boolean;
}

export const NotificationTypeEnum = {
    Like: 'like',
    Comment: 'comment',
    Follow: 'follow',
    Mention: 'mention',
    System: 'system'
} as const;

export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];

/**
 * 
 * @export
 * @interface PaginatedComments
 */
export interface PaginatedComments {
    /**
     * 
     * @type {Array<Comment>}
     * @memberof PaginatedComments
     */
    'data'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedComments
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedComments
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedModerationItems
 */
export interface PaginatedModerationItems {
    /**
     * 
     * @type {Array<ModerationItem>}
     * @memberof PaginatedModerationItems
     */
    'data'?: Array<ModerationItem>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModerationItems
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModerationItems
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedNotifications
 */
export interface PaginatedNotifications {
    /**
     * 
     * @type {Array<Notification>}
     * @memberof PaginatedNotifications
     */
    'data'?: Array<Notification>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotifications
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotifications
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedUsers
 */
export interface PaginatedUsers {
    /**
     * 
     * @type {Array<PublicUser>}
     * @memberof PaginatedUsers
     */
    'data'?: Array<PublicUser>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUsers
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUsers
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedVideos
 */
export interface PaginatedVideos {
    /**
     * 
     * @type {Array<Video>}
     * @memberof PaginatedVideos
     */
    'data'?: Array<Video>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideos
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideos
     */
    'prev_cursor'?: string;
}
/**
 * 
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Problem
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'instance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'trace_id'?: string;
}
/**
 * Offentlige felter (ingen sensitive attributter)
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    'followers_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    'following_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    'likes_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    'verified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequest
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'referral_code'?: string;
}
/**
 * 
 * @export
 * @interface ReportCreate
 */
export interface ReportCreate {
    /**
     * 
     * @type {string}
     * @memberof ReportCreate
     */
    'target_type': ReportCreateTargetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ReportCreate
     */
    'target_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReportCreate
     */
    'reason': ReportCreateReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ReportCreate
     */
    'details'?: string;
}

export const ReportCreateTargetTypeEnum = {
    Video: 'video',
    Comment: 'comment',
    User: 'user'
} as const;

export type ReportCreateTargetTypeEnum = typeof ReportCreateTargetTypeEnum[keyof typeof ReportCreateTargetTypeEnum];
export const ReportCreateReasonEnum = {
    Spam: 'spam',
    Trakassering: 'trakassering',
    Hat: 'hat',
    Nakenhet: 'nakenhet',
    Vold: 'vold',
    Annet: 'annet'
} as const;

export type ReportCreateReasonEnum = typeof ReportCreateReasonEnum[keyof typeof ReportCreateReasonEnum];

/**
 * 
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
    /**
     * 
     * @type {Array<PublicUser>}
     * @memberof SearchResponse
     */
    'users'?: Array<PublicUser>;
    /**
     * 
     * @type {Array<Video>}
     * @memberof SearchResponse
     */
    'videos'?: Array<Video>;
    /**
     * 
     * @type {Array<Hashtag>}
     * @memberof SearchResponse
     */
    'hashtags'?: Array<Hashtag>;
    /**
     * 
     * @type {Array<Sound>}
     * @memberof SearchResponse
     */
    'sounds'?: Array<Sound>;
}
/**
 * 
 * @export
 * @interface Sound
 */
export interface Sound {
    /**
     * 
     * @type {string}
     * @memberof Sound
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sound
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sound
     */
    'artist'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sound
     */
    'duration_ms'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sound
     */
    'playback_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sound
     */
    'is_copyrighted'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadInitRequest
 */
export interface UploadInitRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadInitRequest
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitRequest
     */
    'content_type': string;
    /**
     * 
     * @type {number}
     * @memberof UploadInitRequest
     */
    'size_bytes': number;
    /**
     * 
     * @type {string}
     * @memberof UploadInitRequest
     */
    'checksum_md5'?: string;
}
/**
 * 
 * @export
 * @interface UploadInitResponse
 */
export interface UploadInitResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadInitResponse
     */
    'upload_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitResponse
     */
    'upload_url'?: string;
    /**
     * Les-URL når ferdig prosessert
     * @type {string}
     * @memberof UploadInitResponse
     */
    'content_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitResponse
     */
    'expires_at'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'followers_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'following_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'likes_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'bio'?: string;
    /**
     * Referanse til tidligere opplastet medieobjekt
     * @type {string}
     * @memberof UserUpdate
     */
    'avatar_upload_key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'id': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof Video
     */
    'owner'?: PublicUser;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'caption'?: string;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'playback_url': string;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'aspect_ratio'?: string;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'duration_ms'?: number;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'likes_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'comments_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'shares_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'visibility'?: VideoVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'status': VideoStatusEnum;
    /**
     * 
     * @type {Sound}
     * @memberof Video
     */
    'sound'?: Sound;
    /**
     * 
     * @type {Array<Hashtag>}
     * @memberof Video
     */
    'hashtags'?: Array<Hashtag>;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'created_at'?: string;
}

export const VideoVisibilityEnum = {
    Public: 'public',
    Friends: 'friends',
    Private: 'private'
} as const;

export type VideoVisibilityEnum = typeof VideoVisibilityEnum[keyof typeof VideoVisibilityEnum];
export const VideoStatusEnum = {
    Processing: 'processing',
    Ready: 'ready',
    Blocked: 'blocked',
    Deleted: 'deleted'
} as const;

export type VideoStatusEnum = typeof VideoStatusEnum[keyof typeof VideoStatusEnum];

/**
 * 
 * @export
 * @interface VideoCreate
 */
export interface VideoCreate {
    /**
     * 
     * @type {string}
     * @memberof VideoCreate
     */
    'upload_key': string;
    /**
     * 
     * @type {string}
     * @memberof VideoCreate
     */
    'caption'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoCreate
     */
    'sound_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VideoCreate
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VideoCreate
     */
    'visibility'?: VideoCreateVisibilityEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VideoCreate
     */
    'allow_comments'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VideoCreate
     */
    'allow_duet'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VideoCreate
     */
    'location'?: string;
}

export const VideoCreateVisibilityEnum = {
    Public: 'public',
    Friends: 'friends',
    Private: 'private'
} as const;

export type VideoCreateVisibilityEnum = typeof VideoCreateVisibilityEnum[keyof typeof VideoCreateVisibilityEnum];

/**
 * 
 * @export
 * @interface VideoEvent
 */
export interface VideoEvent {
    /**
     * 
     * @type {string}
     * @memberof VideoEvent
     */
    'event'?: VideoEventEventEnum;
    /**
     * 
     * @type {Video}
     * @memberof VideoEvent
     */
    'video'?: Video;
    /**
     * 
     * @type {string}
     * @memberof VideoEvent
     */
    'fired_at'?: string;
}

export const VideoEventEventEnum = {
    VideoPublished: 'video.published'
} as const;

export type VideoEventEventEnum = typeof VideoEventEventEnum[keyof typeof VideoEventEventEnum];


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List feature-flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFeatureFlagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/feature-flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["admin:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Oppdater flagg
         * @param {Array<FeatureFlagUpdate>} featureFlagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFeatureFlagsPatch: async (featureFlagUpdate: Array<FeatureFlagUpdate>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureFlagUpdate' is not null or undefined
            assertParamExists('adminFeatureFlagsPatch', 'featureFlagUpdate', featureFlagUpdate)
            const localVarPath = `/admin/feature-flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["admin:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(featureFlagUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List feature-flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminFeatureFlagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureFlag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminFeatureFlagsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminFeatureFlagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Oppdater flagg
         * @param {Array<FeatureFlagUpdate>} featureFlagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminFeatureFlagsPatch(featureFlagUpdate: Array<FeatureFlagUpdate>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminFeatureFlagsPatch(featureFlagUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminFeatureFlagsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary List feature-flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFeatureFlagsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<FeatureFlag>> {
            return localVarFp.adminFeatureFlagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Oppdater flagg
         * @param {Array<FeatureFlagUpdate>} featureFlagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFeatureFlagsPatch(featureFlagUpdate: Array<FeatureFlagUpdate>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminFeatureFlagsPatch(featureFlagUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary List feature-flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminFeatureFlagsGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminFeatureFlagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Oppdater flagg
     * @param {Array<FeatureFlagUpdate>} featureFlagUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminFeatureFlagsPatch(featureFlagUpdate: Array<FeatureFlagUpdate>, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminFeatureFlagsPatch(featureFlagUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logg inn med e-post/telefon + passord eller tredjepart (OIDC)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalider gjeldende token og enhetsbinding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forny tilgangstoken
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost: async (refreshRequest: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequest' is not null or undefined
            assertParamExists('authRefreshPost', 'refreshRequest', refreshRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registrer ny bruker
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'registerRequest', registerRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logg inn med e-post/telefon + passord eller tredjepart (OIDC)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invalider gjeldende token og enhetsbinding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forny tilgangstoken
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshPost(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Registrer ny bruker
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Logg inn med e-post/telefon + passord eller tredjepart (OIDC)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthTokens> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalider gjeldende token og enhetsbinding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forny tilgangstoken
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthTokens> {
            return localVarFp.authRefreshPost(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registrer ny bruker
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthTokens> {
            return localVarFp.authRegisterPost(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Logg inn med e-post/telefon + passord eller tredjepart (OIDC)
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalider gjeldende token og enhetsbinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forny tilgangstoken
     * @param {RefreshRequest} refreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshPost(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registrer ny bruker
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrukereApi - axios parameter creator
 * @export
 */
export const BrukereApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List blokkerte brukere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBlocksGet: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hent min profil
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Oppdater min profil
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch: async (userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('usersMePatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Avfølg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdFollowDelete', 'userId', userId)
            const localVarPath = `/users/{userId}/follow`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Følg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowPost: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdFollowPost', 'userId', userId)
            const localVarPath = `/users/{userId}/follow`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hent offentlig profil
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdGet', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrukereApi - functional programming interface
 * @export
 */
export const BrukereApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrukereApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List blokkerte brukere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersBlocksGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersBlocksGet(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersBlocksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Hent min profil
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Oppdater min profil
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMePatch(userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMePatch(userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Avfølg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdFollowDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdFollowDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersUserIdFollowDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Følg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdFollowPost(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdFollowPost(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersUserIdFollowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Hent offentlig profil
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrukereApi.usersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrukereApi - factory interface
 * @export
 */
export const BrukereApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrukereApiFp(configuration)
    return {
        /**
         * 
         * @summary List blokkerte brukere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBlocksGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedUsers> {
            return localVarFp.usersBlocksGet(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hent min profil
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Oppdater min profil
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch(userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersMePatch(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Avfølg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdFollowDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Følg en bruker
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowPost(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdFollowPost(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hent offentlig profil
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<PublicUser> {
            return localVarFp.usersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrukereApi - object-oriented interface
 * @export
 * @class BrukereApi
 * @extends {BaseAPI}
 */
export class BrukereApi extends BaseAPI {
    /**
     * 
     * @summary List blokkerte brukere
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersBlocksGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersBlocksGet(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hent min profil
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersMeGet(options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Oppdater min profil
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersMePatch(userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersMePatch(userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Avfølg en bruker
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersUserIdFollowDelete(userId: string, options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersUserIdFollowDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Følg en bruker
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersUserIdFollowPost(userId: string, options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersUserIdFollowPost(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hent offentlig profil
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrukereApi
     */
    public usersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return BrukereApiFp(this.configuration).usersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedApi - axios parameter creator
 * @export
 */
export const FeedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary «Følger»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedFollowingGet: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feed/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary «For deg»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {string} [xDeviceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedForYouGet: async (cursor?: string, limit?: number, xDeviceID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feed/for-you`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (xDeviceID != null) {
                localVarHeaderParameter['X-Device-ID'] = String(xDeviceID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary «Følger»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedFollowingGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedFollowingGet(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.feedFollowingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary «For deg»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {string} [xDeviceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedForYouGet(cursor?: string, limit?: number, xDeviceID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedForYouGet(cursor, limit, xDeviceID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.feedForYouGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedApiFp(configuration)
    return {
        /**
         * 
         * @summary «Følger»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedFollowingGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<FeedResponse> {
            return localVarFp.feedFollowingGet(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary «For deg»-feed
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {string} [xDeviceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedForYouGet(cursor?: string, limit?: number, xDeviceID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FeedResponse> {
            return localVarFp.feedForYouGet(cursor, limit, xDeviceID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * 
     * @summary «Følger»-feed
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public feedFollowingGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).feedFollowingGet(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary «For deg»-feed
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {string} [xDeviceID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public feedForYouGet(cursor?: string, limit?: number, xDeviceID?: string, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).feedForYouGet(cursor, limit, xDeviceID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InteraksjonerApi - axios parameter creator
 * @export
 */
export const InteraksjonerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Slett egen kommentar
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCommentIdDelete: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('commentsCommentIdDelete', 'commentId', commentId)
            const localVarPath = `/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rapporter innhold eller bruker
         * @param {ReportCreate} reportCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPost: async (reportCreate: ReportCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportCreate' is not null or undefined
            assertParamExists('reportsPost', 'reportCreate', reportCreate)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List kommentarer
         * @param {string} videoId 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdCommentsGet: async (videoId: string, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdCommentsGet', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}/comments`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Opprett kommentar
         * @param {string} videoId 
         * @param {CommentCreate} commentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdCommentsPost: async (videoId: string, commentCreate: CommentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdCommentsPost', 'videoId', videoId)
            // verify required parameter 'commentCreate' is not null or undefined
            assertParamExists('videosVideoIdCommentsPost', 'commentCreate', commentCreate)
            const localVarPath = `/videos/{videoId}/comments`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fjern like
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdLikeDelete: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdLikeDelete', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}/like`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lik en video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdLikePost: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdLikePost', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}/like`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteraksjonerApi - functional programming interface
 * @export
 */
export const InteraksjonerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InteraksjonerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Slett egen kommentar
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCommentIdDelete(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.commentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rapporter innhold eller bruker
         * @param {ReportCreate} reportCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsPost(reportCreate: ReportCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsPost(reportCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.reportsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List kommentarer
         * @param {string} videoId 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdCommentsGet(videoId: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedComments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdCommentsGet(videoId, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.videosVideoIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Opprett kommentar
         * @param {string} videoId 
         * @param {CommentCreate} commentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdCommentsPost(videoId: string, commentCreate: CommentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdCommentsPost(videoId, commentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.videosVideoIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fjern like
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdLikeDelete(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdLikeDelete(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.videosVideoIdLikeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lik en video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdLikePost(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdLikePost(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteraksjonerApi.videosVideoIdLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InteraksjonerApi - factory interface
 * @export
 */
export const InteraksjonerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InteraksjonerApiFp(configuration)
    return {
        /**
         * 
         * @summary Slett egen kommentar
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.commentsCommentIdDelete(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rapporter innhold eller bruker
         * @param {ReportCreate} reportCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPost(reportCreate: ReportCreate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reportsPost(reportCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List kommentarer
         * @param {string} videoId 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdCommentsGet(videoId: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedComments> {
            return localVarFp.videosVideoIdCommentsGet(videoId, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Opprett kommentar
         * @param {string} videoId 
         * @param {CommentCreate} commentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdCommentsPost(videoId: string, commentCreate: CommentCreate, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.videosVideoIdCommentsPost(videoId, commentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fjern like
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdLikeDelete(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.videosVideoIdLikeDelete(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lik en video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdLikePost(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.videosVideoIdLikePost(videoId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InteraksjonerApi - object-oriented interface
 * @export
 * @class InteraksjonerApi
 * @extends {BaseAPI}
 */
export class InteraksjonerApi extends BaseAPI {
    /**
     * 
     * @summary Slett egen kommentar
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).commentsCommentIdDelete(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rapporter innhold eller bruker
     * @param {ReportCreate} reportCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public reportsPost(reportCreate: ReportCreate, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).reportsPost(reportCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List kommentarer
     * @param {string} videoId 
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public videosVideoIdCommentsGet(videoId: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).videosVideoIdCommentsGet(videoId, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Opprett kommentar
     * @param {string} videoId 
     * @param {CommentCreate} commentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public videosVideoIdCommentsPost(videoId: string, commentCreate: CommentCreate, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).videosVideoIdCommentsPost(videoId, commentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fjern like
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public videosVideoIdLikeDelete(videoId: string, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).videosVideoIdLikeDelete(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lik en video
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteraksjonerApi
     */
    public videosVideoIdLikePost(videoId: string, options?: RawAxiosRequestConfig) {
        return InteraksjonerApiFp(this.configuration).videosVideoIdLikePost(videoId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModerasjonAdminApi - axios parameter creator
 * @export
 */
export const ModerasjonAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Utfør tiltak på moderasjonsobjekt
         * @param {string} itemId 
         * @param {ModerationAction} moderationAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModerationItemIdPost: async (itemId: string, moderationAction: ModerationAction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('adminModerationItemIdPost', 'itemId', itemId)
            // verify required parameter 'moderationAction' is not null or undefined
            assertParamExists('adminModerationItemIdPost', 'moderationAction', moderationAction)
            const localVarPath = `/admin/moderation/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["admin:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderationAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hent moderasjonskø
         * @param {AdminModerationQueueGetBucketEnum} [bucket] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModerationQueueGet: async (bucket?: AdminModerationQueueGetBucketEnum, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/moderation/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["admin:read"], configuration)

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModerasjonAdminApi - functional programming interface
 * @export
 */
export const ModerasjonAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModerasjonAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Utfør tiltak på moderasjonsobjekt
         * @param {string} itemId 
         * @param {ModerationAction} moderationAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminModerationItemIdPost(itemId: string, moderationAction: ModerationAction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModerationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminModerationItemIdPost(itemId, moderationAction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModerasjonAdminApi.adminModerationItemIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Hent moderasjonskø
         * @param {AdminModerationQueueGetBucketEnum} [bucket] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminModerationQueueGet(bucket?: AdminModerationQueueGetBucketEnum, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedModerationItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminModerationQueueGet(bucket, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModerasjonAdminApi.adminModerationQueueGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModerasjonAdminApi - factory interface
 * @export
 */
export const ModerasjonAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModerasjonAdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Utfør tiltak på moderasjonsobjekt
         * @param {string} itemId 
         * @param {ModerationAction} moderationAction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModerationItemIdPost(itemId: string, moderationAction: ModerationAction, options?: RawAxiosRequestConfig): AxiosPromise<ModerationResult> {
            return localVarFp.adminModerationItemIdPost(itemId, moderationAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hent moderasjonskø
         * @param {AdminModerationQueueGetBucketEnum} [bucket] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModerationQueueGet(bucket?: AdminModerationQueueGetBucketEnum, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedModerationItems> {
            return localVarFp.adminModerationQueueGet(bucket, cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModerasjonAdminApi - object-oriented interface
 * @export
 * @class ModerasjonAdminApi
 * @extends {BaseAPI}
 */
export class ModerasjonAdminApi extends BaseAPI {
    /**
     * 
     * @summary Utfør tiltak på moderasjonsobjekt
     * @param {string} itemId 
     * @param {ModerationAction} moderationAction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerasjonAdminApi
     */
    public adminModerationItemIdPost(itemId: string, moderationAction: ModerationAction, options?: RawAxiosRequestConfig) {
        return ModerasjonAdminApiFp(this.configuration).adminModerationItemIdPost(itemId, moderationAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hent moderasjonskø
     * @param {AdminModerationQueueGetBucketEnum} [bucket] 
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModerasjonAdminApi
     */
    public adminModerationQueueGet(bucket?: AdminModerationQueueGetBucketEnum, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ModerasjonAdminApiFp(this.configuration).adminModerationQueueGet(bucket, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AdminModerationQueueGetBucketEnum = {
    Spam: 'spam',
    Vold: 'vold',
    Nakenhet: 'nakenhet',
    Trakassering: 'trakassering',
    Annet: 'annet'
} as const;
export type AdminModerationQueueGetBucketEnum = typeof AdminModerationQueueGetBucketEnum[keyof typeof AdminModerationQueueGetBucketEnum];


/**
 * SkApi - axios parameter creator
 * @export
 */
export const SkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Globalt søk
         * @param {string} q 
         * @param {Array<SearchGetTypeEnum>} [type] Resultat-typer å returnere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (q: string, type?: Array<SearchGetTypeEnum>, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchGet', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkApi - functional programming interface
 * @export
 */
export const SkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Globalt søk
         * @param {string} q 
         * @param {Array<SearchGetTypeEnum>} [type] Resultat-typer å returnere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(q: string, type?: Array<SearchGetTypeEnum>, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(q, type, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkApi.searchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkApi - factory interface
 * @export
 */
export const SkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkApiFp(configuration)
    return {
        /**
         * 
         * @summary Globalt søk
         * @param {string} q 
         * @param {Array<SearchGetTypeEnum>} [type] Resultat-typer å returnere
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(q: string, type?: Array<SearchGetTypeEnum>, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchResponse> {
            return localVarFp.searchGet(q, type, cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkApi - object-oriented interface
 * @export
 * @class SkApi
 * @extends {BaseAPI}
 */
export class SkApi extends BaseAPI {
    /**
     * 
     * @summary Globalt søk
     * @param {string} q 
     * @param {Array<SearchGetTypeEnum>} [type] Resultat-typer å returnere
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkApi
     */
    public searchGet(q: string, type?: Array<SearchGetTypeEnum>, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return SkApiFp(this.configuration).searchGet(q, type, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchGetTypeEnum = {
    Video: 'video',
    User: 'user',
    Hashtag: 'hashtag',
    Sound: 'sound'
} as const;
export type SearchGetTypeEnum = typeof SearchGetTypeEnum[keyof typeof SearchGetTypeEnum];


/**
 * VarslerApi - axios parameter creator
 * @export
 */
export const VarslerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List varsler for innlogget bruker
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VarslerApi - functional programming interface
 * @export
 */
export const VarslerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VarslerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List varsler for innlogget bruker
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsGet(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VarslerApi.notificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VarslerApi - factory interface
 * @export
 */
export const VarslerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VarslerApiFp(configuration)
    return {
        /**
         * 
         * @summary List varsler for innlogget bruker
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNotifications> {
            return localVarFp.notificationsGet(cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VarslerApi - object-oriented interface
 * @export
 * @class VarslerApi
 * @extends {BaseAPI}
 */
export class VarslerApi extends BaseAPI {
    /**
     * 
     * @summary List varsler for innlogget bruker
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarslerApi
     */
    public notificationsGet(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return VarslerApiFp(this.configuration).notificationsGet(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideoApi - axios parameter creator
 * @export
 */
export const VideoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List videoer (mine eller filtrert)
         * @param {string} [userId] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGet: async (userId?: string, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fullfør opplasting og publiser video
         * @param {VideoCreate} videoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosPost: async (videoCreate: VideoCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoCreate' is not null or undefined
            assertParamExists('videosPost', 'videoCreate', videoCreate)
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initier video-opplasting (todelt; få pre-signet URL)
         * @param {UploadInitRequest} uploadInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUploadsPost: async (uploadInitRequest: UploadInitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadInitRequest' is not null or undefined
            assertParamExists('videosUploadsPost', 'uploadInitRequest', uploadInitRequest)
            const localVarPath = `/videos/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadInitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Slett min video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdDelete: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdDelete', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hent video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdGet: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosVideoIdGet', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoApi - functional programming interface
 * @export
 */
export const VideoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List videoer (mine eller filtrert)
         * @param {string} [userId] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGet(userId?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVideos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGet(userId, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.videosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fullfør opplasting og publiser video
         * @param {VideoCreate} videoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosPost(videoCreate: VideoCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosPost(videoCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.videosPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initier video-opplasting (todelt; få pre-signet URL)
         * @param {UploadInitRequest} uploadInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosUploadsPost(uploadInitRequest: UploadInitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosUploadsPost(uploadInitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.videosUploadsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Slett min video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdDelete(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.videosVideoIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Hent video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosVideoIdGet(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.videosVideoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideoApi - factory interface
 * @export
 */
export const VideoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideoApiFp(configuration)
    return {
        /**
         * 
         * @summary List videoer (mine eller filtrert)
         * @param {string} [userId] 
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGet(userId?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVideos> {
            return localVarFp.videosGet(userId, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fullfør opplasting og publiser video
         * @param {VideoCreate} videoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosPost(videoCreate: VideoCreate, options?: RawAxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.videosPost(videoCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initier video-opplasting (todelt; få pre-signet URL)
         * @param {UploadInitRequest} uploadInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUploadsPost(uploadInitRequest: UploadInitRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadInitResponse> {
            return localVarFp.videosUploadsPost(uploadInitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Slett min video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.videosVideoIdDelete(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hent video
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.videosVideoIdGet(videoId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoApi - object-oriented interface
 * @export
 * @class VideoApi
 * @extends {BaseAPI}
 */
export class VideoApi extends BaseAPI {
    /**
     * 
     * @summary List videoer (mine eller filtrert)
     * @param {string} [userId] 
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videosGet(userId?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).videosGet(userId, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fullfør opplasting og publiser video
     * @param {VideoCreate} videoCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videosPost(videoCreate: VideoCreate, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).videosPost(videoCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initier video-opplasting (todelt; få pre-signet URL)
     * @param {UploadInitRequest} uploadInitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videosUploadsPost(uploadInitRequest: UploadInitRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).videosUploadsPost(uploadInitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Slett min video
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).videosVideoIdDelete(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hent video
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).videosVideoIdGet(videoId, options).then((request) => request(this.axios, this.basePath));
    }
}



